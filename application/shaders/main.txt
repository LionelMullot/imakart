#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <GL/glew.h>
#include <iostream>
#include <cstdlib>
#include <vector>
#include "VBO.hpp"
#include "VAO.hpp"
#include "glimac.hpp"
#include "Matrix.hpp"
#include "vertex.hpp"
#include "program.hpp"

static const Uint32 FPS = 30;
static const Uint32 FRAME_DURATION = 1000.f / FPS;

static const Uint32 WINDOW_WIDTH = 600;
static const Uint32 WINDOW_HEIGHT = 600;
static const Uint32 WINDOW_BPP = 32;

int main(int argc, char** argv) {
	if(-1 == SDL_Init(SDL_INIT_VIDEO)) {
		std::cerr << "Unable to initialize SDL" << std::endl;
		return EXIT_FAILURE;
	}

	if(NULL == SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_BPP, SDL_OPENGL)) {
		std::cerr << "Unable to open the window and get an OpenGL context" << std::endl;
		return EXIT_FAILURE;
	}

	SDL_WM_SetCaption("OpenGL4Imacs", NULL);

	GLenum glewCode = glewInit();
	if(GLEW_OK != glewCode) {
		std::cerr << "Unable to initialize GLEW : " << glewGetErrorString(glewCode) << std::endl;
		return EXIT_FAILURE;
	}

	IMG_Init(IMG_INIT_PNG);
	SDL_Surface * pTexture = IMG_Load("../textures/triforce.png");
	GLuint idTexture;
	glGenTextures(1,&idTexture);
	glBindTexture(GL_TEXTURE_2D, idTexture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, pTexture->w, pTexture->h, 0, GL_RGB, GL_UNSIGNED_BYTE, pTexture->pixels);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glBindTexture(GL_TEXTURE_2D, 0);


	std::vector<glimac::Vertex2DUV> vertices;
	vertices.push_back(glimac::Vertex2DUV(-1,-1,0,1));
	vertices.push_back(glimac::Vertex2DUV(1,-1,1,1));
	vertices.push_back(glimac::Vertex2DUV(0,1,0.5,0));

	// Initialisation VBO
	glimac::VBO vbo;

	vbo.bind();
	
	// Envoi au GPU
	glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(vertices[0]), vertices.data(), GL_STATIC_DRAW);

	// Débinder le vbo
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	// Initialisation VAO
	glimac::VAO vao;
	// Binder le vao
	vao.bind();

	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	// Binder le vbo
	vbo.bind();
	
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(glimac::Vertex2DUV), glimac::bufferOffset(0));
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(glimac::Vertex2DUV), glimac::bufferOffset(2));
	
	// Débinder le vbo
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	// Debinder le vao
	glBindVertexArray(0);

	// Load des shaders
	glimac::Program program;
	if(argc < 2)
		program = glimac::loadProgram("shaders/tex2D.vs.glsl", "shaders/tex2D.fs.glsl");
	else
		program = glimac::loadProgram(argv[1], argv[2]);
	program.use();

	//Récupération de la variable uniforme 
	GLint locationUMat = glGetUniformLocation(program.getGLId(), "uModelMatrix");
	GLint locationUColor = glGetUniformLocation(program.getGLId(), "uColor");
	GLint locationUTexture = glGetUniformLocation(program.getGLId(), "uTexture");
	
	bool done = false;
	while(!done) {
		Uint32 tStart = SDL_GetTicks();

		// Rendering code goes here
		glClear(GL_COLOR_BUFFER_BIT);
		
		vao.bind();

		//Changement des variables uniformes des shaders
		glimac::Matrix2D Q = glimac::translate(0.5,0.5);
		Q = Q * glimac::scale(0.25, 0.25);
		glUniformMatrix3fv(locationUMat, 1, GL_FALSE, Q.values);
		glBindTexture(GL_TEXTURE_2D, idTexture);
		glUniform1i(locationUTexture,0);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindTexture(GL_TEXTURE_2D, 0);

		//Changement des variables uniformes des shaders
		Q = glimac::translate(-0.5,0.5);
		Q = Q * glimac::scale(0.25, 0.25);
		glUniform3f(locationUColor,0,255,0);
		glUniformMatrix3fv(locationUMat, 1, GL_FALSE, Q.values);
		glBindTexture(GL_TEXTURE_2D, idTexture);
		glUniform1i(locationUTexture,0);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindTexture(GL_TEXTURE_2D, 0);

		//Changement des variables uniformes des shaders
		Q = glimac::translate(0.5,-0.5);
		Q = Q * glimac::scale(0.25, 0.25);
		glUniform3f(locationUColor,0,0,255);
		glUniformMatrix3fv(locationUMat, 1, GL_FALSE, Q.values);
		glBindTexture(GL_TEXTURE_2D, idTexture);
		glUniform1i(locationUTexture,0);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindTexture(GL_TEXTURE_2D, 0);

		//Changement des variables uniformes des shaders
		Q = glimac::translate(-0.5,-0.5);
		Q = Q * glimac::scale(0.25, 0.25);
		glUniform3f(locationUColor,255,0,255);
		glUniformMatrix3fv(locationUMat, 1, GL_FALSE, Q.values);
		glBindTexture(GL_TEXTURE_2D, idTexture);
		glUniform1i(locationUTexture,0);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindTexture(GL_TEXTURE_2D, 0);

		glBindVertexArray(0);
		// Application code goes here

		SDL_Event e;
		while(SDL_PollEvent(&e)) {
			switch(e.type) {
				default:
					break;
				case SDL_QUIT:
					done = true;
					break;
			}
		}

		// Mise à jour de la fenêtre (synchronisation implicite avec OpenGL)
		SDL_GL_SwapBuffers();

		Uint32 tEnd = SDL_GetTicks();
		Uint32 d = tEnd - tStart;
		if(d < FRAME_DURATION) {
			SDL_Delay(FRAME_DURATION - d);
		}
	}
	// Destruction des ressources
	glDeleteTextures(1, &idTexture);
	IMG_Quit();
	SDL_Quit();

	return EXIT_SUCCESS;
}